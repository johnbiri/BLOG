<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Estudos</title>
    <link rel="shortcut icon" href="img/00.ico">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="assets/css/styles.css">
	<link rel="stylesheet" type="text/css" href="assets/header.css">
</head>
<body class="caderno">
	<!-- header -->
	<header class="container-fluid p-0">
		<nav class="navbar navbar-expand-lg">
			<div class="container-fluid">
				<!-- Logo personalizada -->
				<a class="navbar-brand" href="#">
					<img src="img/ico/icon-512x512.png" alt="Ícone do site" class="logo" width="40" height="40">
				  </a>
				<!-- Menu -->
				<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                    <i class="header-toggle d-xl-none bi bi-list fs-1"></i>
				</button>
				<div class="collapse navbar-collapse" id="navbarNav">
					<ul class="navbar-nav ms-auto">
						<li class="nav-item">
							<a class="nav-link text-white" href="003">Voltar</a>
						</li>
						<li class="nav-item">
							<a class="nav-link nav-link-active text-white" href="#">Ruby on Rails</a>
						</li>
					</ul>
				</div>
			</div>
		</nav>
	</header>
    <!-- Tela de carregamento -->
    <div id="loading-screen">
        <div class="spinner"></div>
    </div>
    <!-- Artigo, Conteúdo -->
	<!-- start chrome --app=file:///C:/jb/MyOff/index.html# -->
    <section class="container-fluid text-center p-0 secao1">
		<article class="artigo2">
			<!-- anotações dos estudos -->
			<div>
                <h1>MyOff - Ruby on Rails</h1>
                <!-- Links -->
                <div>
                    <p class="texto04">
                        <br> Links: <br>
                        <a class="link00" href="https://www.udemy.com/course-dashboard-redirect/?course_id=1694986" target="_blank">Curso da Udemy</a>
                    </p>
                </div>
                <p class="texto04">Aprendendo a usar Ruby on Rails para poder participar de projetos:</p>
                <!-- caderno -->
                <div>
                    <p class="texto04"><br><b class="texto05">13/01/2025</b> - Usando uma máquina virtual no Cloud9 (URL: http://localhost:8181/ide.html)<br><br>1. Acessar o terminal no Git Bash<br>2. Ir para o projeto com o comando: <code>cd /c/Projetos/NOME_DO_PROJETO</code><br>3. Dentro da pasta digite o comando: <code>vagrant up</code><br><br>Notas:<br>- <code>vagrant up</code> -> Liga a máquina<br>- <code>vagrant suspend</code> -> Pausa a máquina<br>- <code>vagrant halt</code> -> Desliga a máquina<br>- <code>rvm use x.x.x --default</code> -> Seta a versão como padrão<br>- <code>rvm use ruby-x.x.x</code> -> Usa a versão escolhida<br><br>A seguir comandos do Ruby Version Manager (RVM):<br>1. <code>rvm list known</code> -> Este comando lista todas as versões disponíveis no repositório<br>2. <code>rvm get head</code> -> Atualiza a lista<br>3. <code>rvm list</code> -> Lista as versões instaladas localmente<br>4. <code>rvm install x.x.x</code> -> Instala uma versão escolhida<br>5. <code>rvm install x.x.x --default</code> -> Instala uma versão escolhida e a torna padrão<br><br>Ruby, IRB e Pry:<br>1. Como executar um arquivo Ruby? -> <code>ruby meu_arquivo.rb</code><br>2. Exemplo -> <code>puts "Olá mundo"</code><br><br>Interactive Ruby Shell (IRB) é uma ferramenta (REPL) de linha de comando que permite o desenvolvimento e execução de código Ruby de forma interativa, facilitando o aprendizado, a depuração e a prática do Ruby em tempo real.<br><br>No prompt digite <code>irb</code> Dentro do IRB você pode digitar qualquer instrução Ruby para ser interpretada. Tente:<br>- <code>i1 -> 1+2</code><br>- <code>i1 -> "curso da ruby on rails".reverse</code><br>- <code>i1 -> a = {curso: "rails", versao: "5.x"}</code><br><br>Conhecendo o Pry (https://github.com/pry) - O Pry é uma alternativa ao IRB padrão e vem com algumas melhorias como o syntax highlighting que destaca os elementos dos códigos como cores e a auto-indentação.<br><br>Instalação do Pry -> <code>gem install pry</code><br><br>Tornando Pry padrão ao chamar o IRB:<br>1. Crie o arquivo .irbrc na home do usuário:<br><code>touch ~/.irbrc</code><br>2. Após criar o arquivo edite ele no terminal com o Vim: <code>vim ~/.irbrc</code> ou com o Nano: <code>nano ~/.irbrc</code><br><br>- <code>require 'rubygems'</code><br>- <code>require 'pry'</code><br>- <code>Pry.start</code><br>- <code>exit</code></p>
                    <p class="texto04"><br><b class="texto05">18/01/2025</b> - Como declarar uma variável em Ruby? - Variáveis em Ruby são declaradas apenas "usando-a". - O Ruby infere o tipo da variável no momento da "declaração".<br>- <code>x = 1</code><br>- <code>y = 2.3</code><br>- <code>z = "Rails 5.x"</code><br><br>Para verificar o tipo da variável, use o método `.class`<br><br>Versões Ruby 2.3 vs 2.4<br>2.3<br>- Fixnum representa os inteiros<br>- Bignum representa os números "inteiros gigantes"<br><br>2.4<br>- Integer representa todos os números inteiros<br><br>Saída e Entrada padrão, `/n`, `chomp` e Coerção<br><br>**Saída Padrão - STDOUT**<br>- A saída padrão STDOUT é representada pela "tela".<br>- No Ruby usamos o `puts` para imprimir algo na tela.<br>- <code>puts "Curso de Rails 5.x"</code><br><br>**Entrada Padrão - STDIN**<br>- A entrada padrão STDIN é representado pelo teclado.<br>- No Ruby usamos o `gets` para "ler" algo do teclado.<br>- <code>a = gets</code><br><br>`/n` e `.chomp`<br>- O Código de formatação `/n` indica "new line", ou seja, adiciona uma nova linha.<br>- O `.chomp` é um método que remove o código de formatação `/n` do elemento ao qual foi aplicado.<br><br><code>puts "digite seu nome:"<br>nome = gets<br>puts "-----------------------------------"<br>puts "seu nome é: " + nome<br>puts "-----------------------------------"<br>puts "a variável que recebeu seu nome é do tipo:"<br>puts nome.class<br>puts "-----------------------------------"<br>puts "ela inspecionada contém:"<br>puts nome.inspect<br>puts "-----------------------------------"<br>puts "para remover o /n use o .chomp"<br>puts "-----------------------------------"<br>puts "qual é o seu nome de novo?"<br>nomes = gets.chomp<br>puts "seu nome é: " + nomes<br>puts "agora com o .chomp ele inspecionado ficou assim"<br>puts nomes.inspect<br></code><br><br>**Coerção - cast ou casting**<br>- Coerção, cast ou casting é o procedimento que fazemos para "transformar" o conteúdo de uma variável/entrada em outro tipo.<br>- Nesse caso, não modificamos a variável, apenas "interpretamos" ela como um tipo que queremos.<br>- <code>gets.to_i</code><br>- <code>x = "2.5"</code><br>- <code>x.to_f</code><br><br><code>puts "Abaixo o uso do cast e cating<br>Digite texto na variável a"<br>a = gets.to_f<br>puts "Você digitou:"<br>puts a<br>puts "A classe a é do tipo:"<br>puts a.class<br>puts "\n\n"<br><br>puts "Abaixo o uso do cast e cating<br>Digite texto na variável a"<br>a = gets.to_s<br>puts "Você digitou:"<br>puts a<br>puts "A classe a é do tipo:"<br>puts a.class<br>puts "\n\n"<br><br>puts "Abaixo o uso do cast e cating<br>Digite texto na variável a"<br>a = gets.to_i<br>puts "Você digitou:"<br>puts a<br>puts "A classe a é do tipo:"<br>puts a.class<br></code><br><br>**Estruturas condicionais if, unless, case**<br><br>**if**<br>a. x = 1<br>b. if x > 2<br>c. puts "x é maior que 2"<br>d. end<br><br>**unless**<br>a. x = 1<br>b. unless x >= 2<br>c. puts "x é menor que 2"<br>d. else<br>e. puts "x é maior que 2"<br>f. end<br><br>**case**<br>a. idade = 5<br>b. case idade<br>c. when 0 .. 2<br>d. puts "bebê"<br>e. when 3 .. 12<br>f. puts "criança"<br>g. when 13 .. 18<br>h. puts "adolescente"<br>i. else<br>j. puts "adulto"<br>k. end<br><br>**Estrutura condicional ternária**<br><br>condição ? verdadeiro : falso<br><br><code># vamos aprender a usar o if no Ruby<br>print "digite um número: "<br>a = gets.chomp.to_f<br><br>if a > 2<br>puts "a é maior que 2"<br>else<br>puts "a não é maior que dois"<br>end<br><br>puts "\n\n\n"<br><br># agora o uso do unless<br>print "digite um número: "<br>b = gets.chomp.to_f<br><br>unless b >= 2<br>puts "b é menor que 2"<br>else<br>puts "b é maior ou igual a 2"<br>end<br><br>puts "\n\n\n"<br><br># agora o uso do case<br>print "digite uma idade: "<br>idade = gets.chomp.to_i<br>case idade<br>when 0..2<br>puts "bebê"<br>when 3..12<br>puts "criança"<br>when 13..17<br>puts "adolescente"<br>when 18..49<br>puts "adulto"<br>when 50..99<br>puts "idoso"<br>else<br>puts "ancião"<br>end<br><br>puts "\n\n\n"<br><br># agora o uso da estrutura condicional ternária<br>print "digite y para aceitar e n para recusar: "<br>sexo = gets.chomp.to_s<br>puts sexo == "y" ? (puts "você ganhou R$ 7.000,00") : (puts "você recusou!")<br></code></p>
                    <p class="texto04"><br><b class="texto05">19/01/2025</b> - Operadores Relacionais e Aritméticos<br><br>Relacionais &gt;, &gt;=, &lt;, &lt;=, ==, !=<br><br>Aritméticos +, -, *, /, **, %<br><br>** : potência<br>% : resto da divisão<br><br>Estruturas de repetição - while, each<br><br>- while<br><br>a. i = 0<br>b. num = 5<br>c.<br>d. while i &lt; num do<br>e. puts "Contando... " + i<br>f. i += 1<br>g. end<br><br>em Ruby:<br><br><code># while<br>i = 0<br>num = 5<br><br>while i &lt; num do<br>puts "contando... " + i.to_s<br>i += 1<br>end<br><br># each<br>(0..5).each do |i|<br>puts "O valor lido foi: " + i.to_s<br>end</code><br><br>Vetores / Array<br><br>- Você pode declarar/usar de duas formas:<br><br>a. v = [15, 62, 73, 48]<br><br>- Ou<br><br>a. v = Array.new<br>b. v.push(15)<br>c. v.push(62)<br><br><code>v = [1,3,5,6,7,9]<br><br>v.each do |elem|<br>puts elem<br>end<br><br>v1 = [] # mesma coisa que usar o Array.new<br>v1.push(4)<br>v1.push('Jack')<br><br>v1.each do |elem|<br>puts elem<br>end<br></code><br>- para acessar, use o índice<br><br>a. puts v[0]<br><br>v : 15 [0] 62 [1] 73 [2] 48 [3]<br><br>exemplo em Ruby:<br><br><code>v1 = []<br>v1.push(4)<br>v1.push('jack')<br>v1.push('hello')<br>v1.push(7)<br><br>puts v1[2]<br><br># ele vai imprimir 'hello' que está no índice 2</code><br><br>No Ruby, os arrays são dinâmicos e aceitam armazenar tipos diferentes de dados<br><br>a. v = [\"curso\",62,1.4]<br>b. v.push(\"hello\")<br><br>Arrays podem ser aninhados:<br><br>v = [[11,12,13],[21,22,23],[31,32,33]]<br><br>Podemos usar o each para iterar<br><br>v.each do |externo|<br>externo.each do |interno|<br>puts interno<br>end<br>end<br>Hash - Uma lista do tipo chave => valor<br><br>Em um hash você determina qual é a "chave" para acessar o valor<br><br><code>h = 15 (x) "rails" ("curso") 1997 ("ano") 32 (1)</code><br><br>Você pode criar hashes de duas formas<br><br>Tradicional:<br><code>h = {"x" => 15, "curso" => "rails"}</code><br><br>1.9+<br><code>h = {x: 15, curso: "rails"}</code><br><br>Para acessar os elementos, use os []<br><code>h["curso"]</code><br><br>Strings, Concatenação e Interpolação de Variáveis<br><br>Strings - Strings são determinadas por usar as aspas duplas ou simples<br><code>a. x = "Curso de Rails"<br>b. y = 'Curso de Ruby'</code><br><br>Concatenação de Strings<br><br>+<br><code>a. x = "rails"<br>b. y = "curso " + x<br>c. puts y</code><br><br>&lt;&lt; (shovel)<br><code>a. x = "rails"<br>b. y = "curso " &lt;&lt; x # O valor de x vai para dentro de y (modifica)<br>c. puts y</code><br><br>Diferença entre + e << <br><br><code>a. x = "curso"<br>b. puts x.object_id<br>c. x = x + "rails"<br>d. puts x<br>e. puts x.object_id<br>f. #############<br>g. q = "curso de "<br>h. puts q.object_id<br>i. q &lt;&lt; "rails" # o uso do shovel sempre mantém o mesmo id e não precisa criar um novo objeto<br>j. puts q<br>k. puts q.object_id</code><br><br>O + gera um novo objeto sempre que usado<br><br>Interpolação de Variáveis<br><br>Use a combinação <code>#{}</code> para interpolar strings com variáveis ou código Ruby<br><br><code>a. x = "Jackson"<br>b. puts "Seu nome é #{x}"</code><br><br>Apenas strings criadas com aspas duplas são interpoláveis<br><br>Symbols / Symbols<br><br>Símbolos são "strings imutáveis"<br><br><code>a. puts "jackson".object_id<br>b. puts "jackson".object_id<br>c. puts "jackson".object_id<br>d. #############<br>e. puts :jackson.object_id<br>f. puts :jackson.object_id<br>g. puts :jackson.object_id</code><br><br>Símbolos são muito usados em situações onde precisamos de um identificador pois eles garantem que seu uso não implicará na criação de novos objetos sempre que usados.<br>Hashes adoram símbolos:<br><code>a. h = {:curso => "Rails"}<br>b. h = {curso: "rails"}</code><br><br>Sobre Parênteses e Constantes<br><br>Parênteses - no Ruby, o uso de parênteses é opcional<br><code>a. puts ("Curso Rails")<br>b. puts "Curso Rails"</code><br><br>Constantes - são usadas para representar valores<br><code>a. NOME = "Jackson"<br>b. PI = 3.14<br>c. puts NOME<br>d. puts PI</code><br><br>Tipos Primitivos vs Complexos<br><br>Tipos Primitivos - Tipos básicos da computação<br><br>Inteiro<br><code>x = 1</code><br><br>Real / Float<br><code>y = 3.45</code><br><br>Caracteres / Strings<br><code>z = 'abc'</code><br><br>Lógico / Booleano<br><code>w = true</code><br><br>Tipos complexos - usamos os tipos primitivos para criar tipos complexos<br><br>Podemos dizer que os tipos complexos são as classes/objetos<br><br>Exemplo - A classe Date<br><br>dd/mm/yyyy<br><code>22/12/2009</code><br>i c i c i<br><br>Classes vs objetos<br><br>formas vs objeto pronto<br>As classes são a maneira que temos de informar como queremos que nosso objeto funcione!<br>Ao criarmos uma classe podemos especificar os métodos e os atributos que os objetos possuirão<br>Os métodos são as ações<br>Os atributos são as características<br><br>Métodos e Ações<br>exemplo: (fusca)<br>- Quais os métodos/ações? - (acelera, freia, liga o farol)<br>- Quais os atributos/características? - (é da cor cinza, possui pneus aro 13)<br>Tudo no Ruby é objeto! .class<br>Identificador único do objeto .object_id<br>Qual a vantagem de tudo ser objeto no Ruby? - você "ganha" automaticamente várias ações/métodos em seus objetos.<br>Conheça todos os métodos do objeto usando TAB!<br>Criando Classes e Métodos - Lembre-se! - Uma classe instanciada é um objeto!<br><br># por inferência<br>a = [61,92,37]<br># declaração explícita<br>b = Array.new<br>b.push(53)<br>Como criar uma classe?<br>- Crie um arquivo pessoa.rb<br>- class Pessoa<br>- #### ...<br>- end<br>A classe sempre começa com uma letra maiúscula (capitulada)<br>Nomes compostos devem capitular o início de cada palavra. Ex: PessoaFisica<br>require_relative "pessoa.rb"<br>true<br>p = Pessoa.new<br>p<br>p.class<br>use o irb para testar<br>use o require_relative<br>ps: O nome do arquivo não é obrigado ser o mesmo da classe!<br><br>Métodos - Como criar métodos (ações)?<br>Dentro da classe, use o def / end<br><code>def falar<br>&#x00A0;&#x00A0;"olá, pessoal!"<br>end</code><br>exemplo com a classe Pessoa:<br><code>class Pessoa<br>&#x00A0;&#x00A0;def falar<br>&#x00A0;&#x00A0;&#x00A0;&#x00A0;"olá pessoal"<br>&#x00A0;&#x00A0;end<br>end</code><br><br>Parâmetros e Initialize<br>Parâmetros - é a forma de passar dados para dentro do métodos<br><code>def falar (texto)<br>&#x00A0;&#x00A0;"olá!, #{texto}"<br>end</code><br>Você pode usar um valor padrão...<br><code>def falar (texto = "Olá, tudo bem?")<br>&#x00A0;&#x00A0;texto<br>end</code><br>Você pode usar mais de um parâmetro...<br><code>def falar (texto = "Olá!", texto2 = "Hello")<br>&#x00A0;&#x00A0;"#{texto} - #{texto2}"<br>end</code><br>O Método initialize - é um método especial que serve para indicarmos o que a classe deve fazer ao ser instanciada/inicializada.<br><code>def initialize<br>&#x00A0;&#x00A0;puts "inicializando..."<br>end</code><br>Você também pode usar parâmetros na inicialização<br><code>def initialize (cont = 5)<br>&#x00A0;&#x00A0;cont.times do |i|<br>&#x00A0;&#x00A0;&#x00A0;&#x00A0;puts "Contando... #{i}"<br>&#x00A0;&#x00A0;end<br>end</code></p>
                    <p class="texto04"><br><b class="texto05">25/01/2025</b> - <strong>Self, Variáveis de Instância e Accessors</strong><br><br><strong>Self</strong><br>A grosso modo o self é o próprio objeto, ou seja, o objeto instanciado.<br><br><code>def meu_id<br>&nbsp;&nbsp;&nbsp;&nbsp;"meu ID é o: #{self.object_id}"<br>end</code><br><br>Você também pode reabrir classes no Ruby e usar o self. Veja esse exemplo:<br><br><code>class String<br>&nbsp;&nbsp;&nbsp;&nbsp;def inverter<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.reverse<br>&nbsp;&nbsp;&nbsp;&nbsp;end<br>end</code><br><br><strong>Variáveis de Instância</strong><br>Variáveis de instâncias são as variáveis que existem apenas na instância do objeto (em todo objeto), ou seja, cada objeto possui seus próprios valores em tais variáveis.<br>As variáveis de instância são precedidas de um @.<br><br><code>def initalize (nome_fornecido = "indigente")<br>&nbsp;&nbsp;&nbsp;&nbsp;@nome = nome_fornecido<br>end<br>def imprimir_nome<br>&nbsp;&nbsp;&nbsp;&nbsp;@nome<br>end</code><br><br><strong>Accessors</strong> - Os accessors servem como atalhos para declaração de atributos de uma classe. Veja o exemplo:<br><br><code>attr_accessor :nome</code><br><br>A simples declaração acima te dá um "getter" e um "setter" para nome na classe em questão.<br><br><code>x = Pessoa.new<br>x.nome = "John"<br>x.nome</code><br><br>exemplo:<br><br><code>class Pessoa<br>&nbsp;&nbsp;&nbsp;&nbsp;attr_accessor :nome<br>end<br>p1 = Pessoa.new<br>p1.nome = "John" #setter<br>puts p1.nome #getter</code><br><br><strong>Classe e Herança</strong><br><strong>Representando uma classe visualmente - Notação UML</strong><br>Classe Pessoa representada usando UML<br><br><code>class Pessoa<br>&nbsp;&nbsp;&nbsp;&nbsp;attr_accessor :nome :email<br>&nbsp;&nbsp;&nbsp;&nbsp;def falar(texto)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;texto<br>&nbsp;&nbsp;&nbsp;&nbsp;end<br>&nbsp;&nbsp;&nbsp;&nbsp;def gritar(texto)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"#{texto}!!!"<br>&nbsp;&nbsp;&nbsp;&nbsp;end<br>end</code><br><br>abaixo uma tabela em uml:<br>linha 1: Pessoa<br>linha 2: nome <br> email<br>linha 3: falar(texto) <br> gritar(texto)<br><br><strong>Herança entre Classes</strong><br>Imagine a seguinte situação:<br>Pessoa<br>Pessoa Física<br>Pessoa Jurídica<br>Você deve concordar que tanto a pessoa física como a jurídica "herdam" características e ações da "pessoa genérica". Por exemplo: Ambas possuem nome, endereço, etc.<br>Podemos representar essa situação através de Herança. Veja.<br><br>tabela 1<br>l1: Pessoa<br>l2: nome <br> email<br><br>tabela 2<br>l1: PessoaFisica<br>l2: cpf<br>l3: falar(texto)<br><br>tabela 3<br>l1: PessoaJuridica<br>l2: cnpj<br>l3: pagar_fornecedor()<br><br>a tabela 2 e 3 estão apontando para a tabela 1.<br><br><strong>Convertendo em código seria:</strong><br><br><code>class Pessoa<br>&nbsp;&nbsp;&nbsp;&nbsp;attr_accessor :nome, :email<br>end<br><br>class PessoaFisica &lt; Pessoa<br>&nbsp;&nbsp;&nbsp;&nbsp;attr_accessor :cpf<br>&nbsp;&nbsp;&nbsp;&nbsp;def falar(texto)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;texto<br>&nbsp;&nbsp;&nbsp;&nbsp;end<br>end<br><br>#próxima classe<br><br>class PessoaJuridica &lt; Pessoa<br>&nbsp;&nbsp;&nbsp;&nbsp;attr_accessor :cnpj<br>&nbsp;&nbsp;&nbsp;&nbsp;def pagar_fornecedor<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#...<br>&nbsp;&nbsp;&nbsp;&nbsp;end<br>end</code><br><br></p>
                    <p class="texto04"><br><b class="texto05">26/01/2025</b> - Ou seja, usa-se o menor "&lt;" para indicar a herança.<br>- No Ruby não existe herança múltipla, ou seja, não é possível herdar de várias classes ao mesmo tempo.<br><br>Métodos de Instância e de Classe<br><br> Métodos de Instância - São os métodos que só podem ser invocados a partir de um objeto, ou seja, uma classe instanciada.<br><br><code>class Pessoa<br>&nbsp;&nbsp;&nbsp;&nbsp;attr_accessor :nome, :email<br><br>&nbsp;&nbsp;&nbsp;&nbsp;def falar(texto)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;texto<br>&nbsp;&nbsp;&nbsp;&nbsp;end<br>end</code><br><br>Métodos de Classe - São métodos que podem ser executados a partir da própria classe, ou seja, não é necessário instanciar um objeto.<br><br><code>class Pessoa<br>&nbsp;&nbsp;attr_accessor :nome, :email<br><br>&nbsp;&nbsp;def falar(texto)<br>&nbsp;&nbsp;&nbsp;&nbsp;texto<br>&nbsp;&nbsp;end<br><br>&nbsp;&nbsp;def self.gritar(texto)<br>&nbsp;&nbsp;&nbsp;&nbsp;"#{texto}!!!"<br>&nbsp;&nbsp;end<br>end</code><br><br>...<br><br><code>Pessoa.gritar("Hello")<br><br>#=> Hello!!!</code><br><br>Módulos e Mixins<br><br>Módulos - Módulos Ruby são similares a classes em relação ao fato de que também armazenam uma coleção de <strong>métodos, constantes</strong> e outras definições de <strong>módulos e classes</strong>.<br><br>Entretanto, diferente das classes, você não pode criar objetos baseados em módulos nem pode criar módulos que herdam desse módulo; ao invés disso, você especifica qual funcionalidade de um módulo específico você deseja adicionar a uma classe ou a um objeto específico.<br><br>Módulos permanecem sozinhos; não há hierarquia de módulos ou herança. Módulos são um bom lugar para armazenar constantes em um local centralizado.<br><br>Principais objetivos dos Módulos:<br><br>Primeiro eles agem como namespace, permitindo que você defina métodos cujos nomes não irão colidir com aqueles definidos em outras partes de um programa.<br><br>Em segundo lugar, permitem que você compartilhe funcionalidade entre classes - se  uma classe "mistura" (mixes in) um módulo (isto é, o inclui), todos os métodos de instância do módulo se tornam disponíveis como se tivessem sido definidos na classe.<br><br>exemplo com constantes:<br><br><code>require_relative 'pagamento'<br><br>include Pagamento<br><br>puts Pagamento::PI<br>puts PI</code><br><br>...<br><br><code>module Pagamento<br>&nbsp;&nbsp;PI = 3.14<br>end</code><br><br>exemplo com métodos:<br><br><code>require_relative 'pagamento'<br><br>include Pagamento<br><br>puts "Digite a bandeira do cartão:"<br>b = gets.chomp<br><br>puts "Digite o número do cartão:"<br>n = gets.chomp<br><br>puts "Digite o valor da compra:"<br>v = gets.chomp<br><br>puts pagar(b, n, v)<br>puts Pagamento::pagar(b, n, v)</code><br><br>...<br><br><code>module Pagamento<br>&nbsp;&nbsp;def pagar(bandeira, numero, valor)<br>&nbsp;&nbsp;&nbsp;&nbsp;"Pagamento com o cartão #{bandeira} Número #{numero}, o valor de R$ #{valor}..."<br>&nbsp;&nbsp;end<br>end</code><br><br>Exemplo para Classes<br><br><code>require_relative 'pagamento'<br><br>include Pagamento<br><br>p1 = Pagamento::Visa.new<br>puts p1.pagando</code><br><br>...<br><br><code>module Pagamento<br>&nbsp;&nbsp;class Visa<br>&nbsp;&nbsp;&nbsp;&nbsp;def pagando<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"pagando..."<br>&nbsp;&nbsp;&nbsp;&nbsp;end<br>&nbsp;&nbsp;end<br>end</code><br><br>exemplo para módulos dentro de módulos<br><br><code>require_relative 'pagamento'<br><br>include Pagamento::Master<br><br>puts Pagamento::Master::pagando</code><br><br>...<br><br><code>module Pagamento<br>&nbsp;&nbsp;module Master<br>&nbsp;&nbsp;&nbsp;&nbsp;def pagando<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"pagando..."<br>&nbsp;&nbsp;&nbsp;&nbsp;end<br>&nbsp;&nbsp;end<br>end</code><br><br>Gems - Gems são bibliotecas ou conjuntos de arquivos Ruby reutilizáveis, etiquetados com um nome e uma versão.<br><br>Listando as gems<br><br>Gems instaladas localmente (perceba as versões)<br><code>gem list</code><br><br>Pesquisa aproximada (localmente)<br><code>gem list &lt;nome da gem&gt;</code><br><br>Pesquisa aproximada (remotamente)<br><code>gem list &lt;nome da gem&gt; --remote</code><br><br>Pesquisa aproximada (remotamente para todas as versões)<br><code>gem list &lt;nome da gem&gt; --remote --all</code><br><br>Instalando<br><br>Instalação básica de uma gem<br><code>gem install &lt;nome da gem&gt;</code><br><br>Instala uma gem em uma versão específica<br><code>gem install &lt;nome da gem&gt; -v &lt;versão x.x.x&gt;</code><br><br>Removendo<br><br>Remove uma gem<br><code>gem uninstall &lt;nome da gem&gt;</code><br><br>Remove versões antigas da gem<br><code>gem cleanup</code><br><br>Remove versões antigas de uma determinada gem<br><code>gem cleanup &lt;nome da gem&gt;</code><br><br>Verifica versões que serão apagadas<br><code>gem cleanup -d</code><br><br>Usando uma gem a primeira vez<br><br>Siga os passos...<br><br>Instale a gem<br><code>gem install cpf_utils</code><br><br>Importe a gem no seu projeto/arquivo/irb<br><code>require 'cpf_utils'</code><br><br>Use a gem<br><code>CpfUtils.cpf</code><br><br>O Bundler<br><br>O que são as dependências?<br><br>Algumas gems precisam de outras gems para funcionar corretamente.<br><br>O bundler é uma gem!<br>Como funciona?<br><br>Crie um arquivo Gemfile<br><code>Gemfile</code><br><br>Adicione um repositório<br><code>source 'https://rubygems.org'</code><br><br>Adicione as gems que deseja instalar<br><code>gem 'lerolero'<br>gem 'cpf_utils'<br>gem 'faker'</code><br><br>Após adicionar as gems salve, saia do arquivo e execute no terminal o bundle<br><br><code>bundle install</code><br><br>Nesse momento será gerado um arquivo <strong>Gemfile.lock</strong> contendo informações sobre todas as gems que seu projeto usa.<br><br>Isso vai te dar a possibilidade de junto aos seus projetos indicar quais gems foram usadas.<br><br><strong>Versionamento de Gems</strong><br><br>Sistema comum de versionamento...<br><br>X.Y.Z (Major.Minor.Patch)<br><code>gem "cpf_utils", "1.0.0"</code><br><br>Basicamente o <strong>Patch</strong> é para correções, <strong>Minor</strong> para alterações pequenas e <strong>Major</strong> quando as alterações são grandes, muitas vezes impactando na forma de usar a gem.<br><br>exemplos:<br><br><code>gem 'lerolero', '1.0.1'<br>gem 'cpf_utils', '>=1.0.0'<br>gem 'faker', '~>1.6.0'</code><br><br>Versão Exata: gem 'lerolero', '1.0.1'<br><br>Versão Igual ou maior que... gem 'cpf_utils', '>=1.0.0'<br><br>Versão 'parcial' atual... gem 'faker', '~>1.6'<br><br>&lt; 2.0<br><br>gem 'faker', '~>1.0.2'<br><br>&lt; 1.1<br><br><strong>Conhecendo algumas gems</strong><br><br>Lero-Lero Generator<br><code>https://github.com/jacksonpires/lerolero_generator</code><br><br>CPF Utils<br><code>https://github.com/jacksonpires/cpf_utils</code><br><br>Documentos BR<br><code>https://github.com/jacksonpires/documentos_br</code><br><br>TTY Toolbox<br><code>http://piotrmurach.github.io/tty/</code><br><br><strong>Módulo 3</strong><br><br>Iniciando o módulo 3<br><br>Vamos desenvolver nossa primeira aplicação.<br>A aplicação será simples.<br>A importância desse módulo vai ser conhecer alguns conceitos importantes sobre o Rails.<br>Vamos conhecer inicialmente onde buscar ajuda. Documentação!<br><br>Ruby: <code>https://www.ruby-lang.org/pt/</code><br>Documentação: <code>https://www.ruby-lang.org/pt/documentation/</code><br>Core: <code>http://ruby-doc.org/core-2.5.1/</code><br>Standard Library: <code>http://ruby-doc.org/stdlib-2.5.1/</code><br>API Dock: <code>https://apidock.com/ruby</code><br><br>Ruby on Rails: <code>https://rubyonrails.org/</code><br>Guides: <code>http://guides.rubyonrails.org/</code><br>API: <code>http://api.rubyonrails.org/</code><br>API Dock: <code>https://apidock.com/rails</code><br><br>Documentação Offline: <code>http://devdocs.io/</code><br><br><strong>Conhecendo e iniciando a nossa 1a aplicação</strong><br><br>Nome da aplicação: <strong>Crypto Wallet</strong><br><br>1a Parte<br><br>- Cadastrar as moedas, suas imagens e siglas<br><br>Ex:<br><br>Bitcoin - BTC logo<br>Litecoin - LTC logo<br>Dash - DASH logo<br>Ethereum - ETH logo<br><br>Qual "stack" vamos usar?<br><br>ruby (linguagem)<br>ruby on rails (framework)<br>Sqlite (banco de dados)<br><br><strong>Gere a aplicação</strong><br>Use a versão 5.2 do Rails<br><br><code>rails _5.2_ new crypto_wallet</code><br><br>Veja outras opções: Digite "rails" e dê ENTER</p>
                    <p class="texto04"><br><b class="texto05">27/01/2025</b> - Usando outro BD e Conhecendo as pastas do projeto<br><br><strong>Usando outro BD</strong> - Para saber qual o BD que está sendo usado na aplicação, verifique o arquivo <strong>config/database.yml</strong><br><br>Digitando <strong>rails</strong> fora da pasta podemos ver a opção <strong>--database</strong> que permite a configuração para outros BD.<br><br>Ex:<br><code>rails new meu_app --database=&lt;nome bd&gt;</code><br><br>Você pode verificar a funcionalidade de cada pasta em: <code>http://guides.rubyonrails.org/v5.2/getting_started.html#creating-the-blog-application</code><br><br><strong>Prototipando:</strong> - Quando falamos em protótipo, estamos falando em tentar passar, na maioria das vezes para o cliente, como o software ficará visualmente, permitindo que o cliente possa entender e opinar sobre os aspectos visuais e funcionais do sistema.<br><br>Algumas ferramentas ajudam a prototipar e também a gerar código dando vida ao protótipo. Veja esses exemplos:<br><strong>Adobe XD: </strong><code>https://www.adobe.com/br/products/xd.html</code><br><strong>Balsamiq: </strong><code>https://balsamiq.com/</code><br><strong>Mock Flow:</strong><code>https://mockflow.com</code><br><br><strong>Modelagem de Dados:</strong> A Modelagem de Dados é a criação de um modelo físico que explique a lógica por trás do sistema, com ele você é capaz de explicar as características de funcionamento e comportamento de um software.<br><br>- A modelagem de dados é a base de criação do Banco de dados e parte essencial para a qualidade do software<br><br>Imagine uma tabela de excell...</p><table><tr><th>nome da moeda</th><th>sigla da moeda</th><th>logo da moeda</th></tr><tr><td>Bitcoin</td><td>BTC</td><td>http://site.com/bitcoin.jpg</td></tr><tr><td>Litecoin</td><td>LTC</td><td>http://site.com/litecoin.jpg</td></tr></table><p class="texto04"><br><strong>MVC</strong> - Model, View, Controller<br><br>É um padrão de arquitetura de software que separa a representação da informação da interação do usuário.<br>Observe a pasta <strong>app</strong> do seu projeto Rails<br><br><strong>Criando o primeiro CRUD usando Scaffold</strong><br>CRUD? (Create, Read, Update, Delete) Operações básicas em um BD/Tabela<br>Scaffold - O rails possui um generator chamado scaffold que permite criar um CRUD para uma determinada "tabela"<br><br><strong>Scaffold</strong> - Para usar o generate para scaffold do Rails, rode o comando... <code>rails generate scaffold &lt;Model&gt; &lt;campo:tipo&gt;<br>&lt;campo:tipo&gt;</code> ...<br><br>Transformando a modelagem em scaffold...<br>- Programe em inglês<br>Dê preferência de escrever todos os models em inglês<br><strong>Convenção: </strong>Um model é sempre escrito com a primeira letra maiúscula e no singular.<strong> Coin</strong><br><br>Tipos de campos: <code>http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-add_column</code><br><br><code>description: string<br>acronym: string<br>url_image: string</code><br><br>Sendo assim...<br><code>rails generate scaffold Coin description:string acronym:string url_image:string</code><br><br>ou<br><br><code>rails generate scaffold Coin description acronym url_image</code><br><br>O comando anterior cria diversos arquivos que podem ser acompanhados pelo log, e dentre eles temos:<br>1 - As views<br>2 - O controller<br>3 - O model<br>4 - A <strong>migração (migration)</strong><br><br>Entendendo sobre Migrations e ORM - <strong>Migrations</strong> - Quando falamos sobre Migrations precisamos falar sobre Active Record e ORM. <strong>Active Record: </strong>é o M do MVD. O model.<br> É a camada de software responsável pela lógica de dados do negócio.<br><br><code>http://guides.rubyonrails.org/v5.2/active_record_basics.html</code><br><br>Não confunda o padrão Active Record com o framework Active Record!<br>Nesse caso o framework é a implementação do padrão!<br><br><code>https://pt.wikipedia.org/wiki/Active_record</code><br><br><strong>ORM</strong> vem de Object-Relational Mapping<br>Em resumo, é uma técnica que mapeia os dados em um BD para classes/objetos na programação <code>https://pt.wikipedia.org/wiki/Mapeamento_objeto-relacional</code><br><br><strong>Voltando às Migrations</strong> - Em resumo, migrations são uma característica do Active Record (o framework) que permite você "escrever/especificar" as tabelas do BD usando a linguagem Ruby.<br>Dessa forma, você pode adicionar, modificar e remover tabelas do BD sem utilizar SQL, além de ter sempre disponível toda a sequência de criação/alteração das tabelas envolvidas nos projeto.<br>As migrações também controlam quais já foram ou não aplicadas o BD através do arquivo <strong>db/schema.rb</strong>.<br><code>http://guides.rubyonrails.org/v5.2/migrations.html</code> As migrations ficam localizadas em <strong>db/migrate</strong> em seu projeto. Confira. Sempre que criamos migrações, precisamos fazê-las "migrar" para o BD, ou seja, aplicar as mudanças no BD. Para isso, usamos algumas <strong>tasks</strong> predefinidas no Rails.<br><br><strong>Rails dbconsole, Rails Tasks e primeiro acesso</strong><br><br><strong>rails dbconsole</strong> é o comando usado para se conectar ao BD e executar comandos para inspecioná-lo. <strong>Rails Tasks?</strong> São tarefas predefinidas que o Rails pode executar. Para conhecer todas as tasks disponíveis rode <code>rails -T</code>. Para filtrar tasks específicas use as iniciais do que procura, por exemplo: <code>rails -T db</code>. As tasks de banco de dados mais usadas são:<br><br><code>rails db:create&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#cria o db<br>rails db:drop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#apaga o db<br>rails db:migrate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#executa as migrations<br>rails db:rollback&nbsp;&nbsp;&nbsp;&nbsp;#desfaz a última migration</code><br><br>Sendo assim... Precisamos criar o BD a primeira vez. <code>rails db:create</code>. Na sequência aplicamos as migrações. <code>rails db:migrate</code><br><br><strong>Inicie o servidor do Rails</strong> <code>rails server</code> <strong>no meu caso devo usar o <code>rails server -b 0.0.0.0</code> para acessar o localhost fora da máquina virtual</strong> e acessar no navegador o <code>localhost:3000/coins</code><br><br>Ambientes do Rails - Por padrão, o Rails vem com 3 ambientes: <strong>Desenvolvimento</strong>, <strong>Teste</strong> e <strong>Produção</strong>. Esses ambientes possibilitam ter configurações isoladas para cada ambiente. A sua Gemfile é a forma mais simples de perceber isso. <code>http://guides.rubyonrails.org/configuring.html#creating-rails-environments</code> <strong>Fluxo MVC e "acesso padrão" aos controllers</strong> Após criarmos nosso scaffold, ganhamos model, views e controller para "Coin" que foi o nome escolhido para o nosso model. Observe no projeto. Daí, usamos o path <strong>/coins</strong> para acessar a página principal. Isso ocorre por alguns motivos, dentre eles é que o controller foi gerado com o nome <strong>coins_controller</strong> (a convenção do Rails é ter controllers sempre como arquivos com <strong>???_controller.rb</strong>) Dentro do controller temos algumas actions (que são métodos) e dentre elas uma chamada <strong>index</strong> (que é a action "padrão") Sendo assim, ao acessar <strong>/coins</strong> pelo navegador indica que vamos para o controlller coins e por ser um acesso "padrão" a action index será invocada, disparando na sequência o arquivo da view com o mesmo nome, nesse caso <strong>app/views/coins/index.html.erb</strong> Entender esse fluxo inicial é de suma inportância para o entendimento do Rails como um todo!<br><br><strong>Novos generators e tela de Boas Vindas</strong> - Conhecendo novos generators - No rails, podemos conhecer novos generators simplesmente digitando um dos comandos abaixo...<br><br><code>rails generate<br>rails g</code><br><br>Ao digitar o comando acima, o rails mostrará os generators disponíveis. Novos generators podem ser adicionados ao usarmos algumas gems (geralmente a documentação da gem indica isso). Dentre os generators apresentados, temos o generator do scaffold (MVC), do model e do controller. Mas cadê o generator das views? Antes disso teste criar um controller e depois destruí-lo usando o <code>rails destroy</code> ...Perceba que a conversação do Controller com o Model é opcional mas o Controller e a View sempre andam juntos. Agora que conhecemos como o Fluxo MVC funciona na aplicação Rails, sabemos que para cada action deve existir uma view associada, correto? Verifique no projeto. Em seguida usando o generator do controller, faça: <code>rails g controller welcome index</code> usando dessa forma, indicamos que queremos um controller chamado welcome com uma action chamada index, e por consequência também será gerada a estrutura da view baseada na action. Simples, não? :-) Agora basta adicionar o conteúdo na view, e pronto! Pode testar sua app novamente acessando <strong>/welcome</strong> Oops... não vai funcionar... Podemos então perceber na tela de erro que existe agora uma rota chamada <strong>/welcome/index</strong> que será a nossa rota correta. <strong>ERB</strong> Embedded Ruby - Em resumo, é uma forma de você mesclar texto com código Ruby. A princípio você pode achar que uma simples "interpolação" com <strong>#{ }</strong> resolveria, mas o ERB te dá a oportunidade de trabalhar com textos, HTML e expressões Ruby, ou seja, ele é muito mais completo e complexo do que uma simples interpolação. Sendo assim, diz-se que ERB é um sistema de templates para o Ruby.<br><br><code>https://pt.wikipedia.org/wiki/ERuby</code><br><br>veja a documentação: <code>http://ruby-doc.org/stdlib-2.4.0/libdoc/erb/rdoc/ERB.html</code> No nosso caso, o melhor é testar isso em nossa página de Boas Vindas. No Arquivo <strong>app/views/welcome/index.html.erb</strong> digite <code>&lt;%= 1 + 1 %&gt;<br>&lt;%= Date.today %&gt;</code> Perceba que o formato do arquivo é HTML.ERB, ou seja serão usados HTML e Ruby no arquivo.<br><br><strong>Helpers</strong> <code>http://api.rubyonrails.org/classes/ActionController/Helpers.html</code> Em resumo, helpers são métodos prontos que podem ser usados nas views. Esses métodos geralmente facilitam a vida do programador, fazendo com que menos código seja escrito para que se consiga o mesmo resultado. Vamos conhecer o helper <strong>link_to</strong> Um pouco mais sobre Helpers. Vamos ajustar as imagens das moedas?<br><br>Sabe-se que para colocar uma imagem em html usa-se por exemplo o... <code>&lt;img src="http://abc.com/imagem.jpg" /&gt;</code><br><br>Você pode conseguir o resultado esperado para as moedas, usando... <code>&lt;img src="&lt;%= coin.url_image %&gt;" /&gt;</code> No entanto, vamos usar o helper image_tag para conseguir o mesmo resultado... <code>&lt;%= image_tag coin.url_image %&gt;</code><br><br><strong>image_tag</strong> <code>https://api.rubyonrails.org/classes/ActionView/Helpers/AssetTagHelper.html#method-i-image_tag</code><br><br>Criando seus próprios Helpers - O Rails permite que você crie seus próprios Helpers. Para isso, existe uma pasta <strong>app/helpers</strong> que permite esse feito. Perceba que essa pasta possui um arquivo <strong>application_helper.rb</strong> e outros arquivos com o nome das views <strong>*_helper.rb</strong> - Os nomes dos arquivos são para facilitar a organizão na hora de criar seus helpers. Todos os helpers criados serão disponibilizados para as views. Dentro do arquivo <strong>application_helper.rb</strong> crie uma função conforme abaixo... <br><code>def data_br(data_us)<br>&nbsp;&nbsp;data_us.strftime(%d/%m/%Y)<br>end</code><br><br><strong>Documentação strftime: </strong><code>https://apidock.com/ruby/DateTime/strftime</code></p>
                    <p class="texto04"><br><b class="texto05">28/01/2025</b> - Rotas e REST - HTTP - Protocolo padrão de acesso a Internet. HTTP - Verbos - GET / POST<br><strong>GET: </strong>Usado quando digitamos diretamente a URL no navegador. <strong>POST: </strong>Usado por formulários da Web (dados enviados por 'debaixo dos panos') - E para apagar? GET ou POST?<br><strong>REST</strong> - Representational State Transfer (Transferência de Estado Representacional).<br>- 2000 - Roy Fielding<br>- Idealizou que o HTTP deveria ter 1 verbo para cada uma das ações do CRUD <strong>Recurso:</strong> POST, GET, PUT, DELETE<br>Veja o mapeamento das rotas do Rails <code>http://guides.rubyonrails.org/routing.html#crud-verbs-and-actions</code><br><br>Rotas: <code>http://localhost:3000/rails/info/routes</code> - Vamos começar fazendo o mapeamento da rota padrão. O arquivo do Rails que faz o mapeamento das rotas é o <strong>config/routes.rb</strong> - Para fazermos o mapeamento padrão devemos usar a instrução root to: <code>root to: "welcome#index"</code><br>- <a target="_blank" href="http://guides.rubyonrails.org/routing.html#using-root">Documentação</a><br>- <a target="_blank" href="https://www.videosdeti.com.br/courses">Aprenda mais sobre REST!</a></p><p class="texto04"><strong>Um pouco mais sobre Rotas</strong> - <a target="_blank" href="https://guides.rubyonrails.org/routing.html#crud-verbs-and-actions">Resources</a> no Rails. Quando usamos a palavra resources no mapeamento das rotas do Rails, de forma automática ele entenderá que queremos criar 7 rotas padrão para o CRUD. Para criar suas próprias rotas apenas declare o verbo e a url e o controller e action que deve responder à url indicada, veja o exemplo: <code>get '/inicio', to: 'welcome#index'</code> - A rota acima permitirá que seja digitada a url /inicio e ela acessará o controller <strong>welcome</strong> e ação <strong>index</strong><br><br><strong>Rails Console</strong> - <a target="_blank" href="https://guides.rubyonrails.org/command_line.html#rails-console">Documentação</a>. O Rails Console permite você interagir com sua aplicação a partir do terminal. <code>rails console<br>rails c</code><br>Você pode rodar o rails  console com a opção <strong>-e</strong> passando o ambiente que quer usar <code>rails console -e production</code> - Você pode também usar o rails console com a opção <strong>--sandbox</strong> para que nenhum dado seja alterado na aplicação <code>rails console --sandbox</code> - O Rails console também permite você usar objetos app e helper, a fim de testar por exemplo os paths e verificar as saídas dos helpers depois de processado. Veja: <code>app.root_path<br>helper.link_to "teste", "/teste"<br>helper.data_br(Date.today)</code><br><br><strong>Trabalhando com Models via Rails Console</strong> - No Rails console podemos trabalhar com qualquer model, bastando para isso invocar o seu nome e usar os métodos disponíveis a partir do Active Record.<br><br><code>Coin.first # retorna o primeiro elemento<br>Coin.last # retorna o último elemento<br>Coin.all # retorna todos os elementos</code> - Perceba que os métodos anteriores first e last retornam um único elemento, já o método all retorna um array de elementos. <code>Coin.all # retorna todos os elementos</code> - Ou seja, se for necessário, itere no array para conseguir cada um dos elementos. <code>Coin.all.each do |coin|<br>&nbsp;&nbsp;puts coin<br>end</code><br>Veja mais alguns usos. Criando uma nova moeda.<br><br><code>c = Coin.new<br>c.description = "Dash"<br>c.acronym = "DASH"<br>c.url_image = "http://"<br>c.save!</code><br><br>Outra forma de criar uma nova moeda.<br><br><code>c = Coin.create! (<br>&nbsp;&nbsp;description: "Dash",<br>&nbsp;&nbsp;acronym: "DASH",<br>&nbsp;&nbsp;url_image: "http://"<br>)</code><br><br>Você pode explorar outros métodos digitando nome do model com um ponto e pressionando TAB. <code>Coin.<br>Display all 616 possibilities? (y or n)</code><br><br>Identificando os "ambientes" no Rails<br><br>Para resolver esse problema podemos simplesmente usar a instrução... <code>Rails.env</code> - Ou ainda... <code>Rails.env.production?<br>Rails.env.development?</code><br><br><strong>Variáveis de instância/sessão no Rails</strong> - As variáveis que começam com "@" são variáveis de instância quando usamos a Orientação a Objetos, lembram?<br><br><code>class Pessoa<br>&nbsp;&nbsp;@nome = ""<br>&nbsp;&nbsp;def initialize(nome)<br>&nbsp;&nbsp;&nbsp;&nbsp;@nome = nome<br>&nbsp;&nbsp;end<br>&nbsp;&nbsp;def meu_nome<br>&nbsp;&nbsp;&nbsp;&nbsp;@nome<br>&nbsp;&nbsp;end<br>end</code><br><br>Pois bem, no caso do Rails é comum chamarmos as variáveis que começam com "@" de variáveis de sessão, visto que essas variáveis terão um valor único para cada sessão no navegador que for aberta.<br><br>Query Params para Requests - Lembra dos Hashes?<br><br><code>h = {nome: "John", curso: "Rails"}<br>h[:nome]<br>h[:curso]</code><br><br><strong>Query Params:</strong> são parâmetros enviados para o sevidor através da URL. Para isso basta usar, logo após a URL padrão, o símbolo de interrogação <strong>"?"</strong> seguido de um par <strong>chave=valor</strong> para o que se quer passar para o servidor.<br><br>Vejamos o exemplo... http://localhost:3000/?nome=John<br> - Acessando a URL acima, podemos informar o parâmetro nome para o servidor.<br>- No servidor, no controller, podemos acessá-lo através da variável global params.<br><br><code>params[:nome]</code><br><br>- Assim podemos usar o valor que foi passado (John) do jeito que quisermos.<br>- Uma pequena documentação pode ser obtida <a href="https://guides.rubyonrails.org/action_controller_overview.html#parameters" target="_blank">aqui</a>.<br><br><strong>Partials</strong> permitem você renderizar uma view dentro de outra, ou seja, "reutilizar páginas/views"</p><ul><li><p>Para isso crie um arquivo <strong>_menu.html.erb</strong></p></li><li><p>Perceba o _ "underline" no início do nome do arquivo</p></li><li><p>Dentro dele coloque o conteúdo que está entre <strong>&lt;ul&gt;&lt;/ul&gt;</strong> da página <b>app/views/welcome/index.erb</b></p></li></ul>
                    <h2>Layouts</h2>
                    <ul>
                        <li>
							<p>Quando acessamos uma URL o Rails, no momento em que vai enviar a resposta para o usuário, renderiza um layout padrão (application) antes de renderizar a view que solicitamos.</p>
						</li>
						<li>Documentação:
							<ul>
								<li><a href="https://api.rubyonrails.org/classes/ActionView/Layouts.html" target="_blank">Layouts</a></li>
								<li><a href="https://api.rubyonrails.org/layouts_and_rendering.html" target="_blank">Layouts and Rendering</a></li>
							</ul>
						</li>
					</ul>
					<h2>Fluxo MVC do CRUD (Index)</h2>
					<ul>
						<li><p>No caso da action <b>index</b>, todas as moedas são buscadas na model <b>Coin</b> e enviadas através da variável de instância <b>@coins</b>.</p></li>
						<li><p>Ao chegar na view, a variável <b>@coins</b> é iterada e <b>processada junto ao HTML</b> para que sejam mostradas todas as moedas.</p></li>
					</ul>
					<h2>Um pouco mais sobre "Permissão de parâmetros"</h2>
					<ul>
						<li><p>A permissão de parâmetros é uma prática que visa informar quais dados que estão chegando ao controller são permitidos para serem manipulados</p></li>
						<li><p>O Rails trata isso através do framework Action Controller e nos dá os métodos <b>require</b> e <b>permit</b> para usarmos com essa finalidade.</p></li>
						<li><a href="https://api.rubyonrails.org/classes/ActionController/Parameters.html" target="_blank">Documentação</a></li>
					</ul>
					<h2>A task db:seed</h2>
                </div>
			</div>
		</article>
	</section>
    <!-- Rodapé -->
    <footer id="fim1" class="container-fluid text-center footer1">
        <p class="footer2">
            <a href="https://www.instagram.com/johnbiri" target="_blank"><i class="bi bi-instagram icon1 fs-3"></i></a> |
            <a href="https://www.youtube.com/@John-Biri" target="_blank"><i class="bi bi-youtube icon1 fs-3"></i></a> |
            <a href="https://x.com/AnneCasmurro" target="_blank"><i class="bi bi-twitter-x icon1 fs-3"></i></i></a>
        </p>
        <p class="texto04">"A chave para o sucesso <br> não é a velocidade, mas <br> a direção."</p> 
        <p class="texto05">Foi o que ela disse</p>
        <p class="footer2"><span class="icon"><i class="bi bi-c-circle icon1 fs-3"></i> JB 2024</span></p>            
    </footer>
    <script src="js/loading.js"></script>
    <script src="js/sons.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
</body>